# Transformers
## Introduction
A transformer is a deep learning architecture developed by Google and based on the multi-head attention mechanism. It is based on the softmax-based attention 
mechanism. Before transformers, predecessors of attention mechanism were added to gated recurrent neural networks, such as LSTMs and gated recurrent units (GRUs), which 
processed datasets sequentially. Dependency on previous token computations prevented them from being able to parallelize the attention mechanism.

## Model Architecture
<p align="center"><img src="https://github.com/SAM-DEV007/learn-python/assets/60264918/c290ed33-46ff-4b80-8212-47cfe7fbceb3" alt="Model Architecture" /></p>

### Encoder
The encoder is composed of a stack of identical layers. Each layer has two sub-layers. The first is a multi-head self-attention mechanism, and the second is a simple, positionwise fully connected feed-forward network. Each encoder consists of two major components: a self-attention mechanism and a feed-forward neural network. The self-attention mechanism accepts input encodings from the previous encoder and weights their relevance to each other to generate output encodings. The feed-forward neural network further processes each output encoding individually. These output encodings are then passed to the next encoder as its input, as well as to the decoders.

### Decoder
The decoder is also composed of a stack of identical layers. In addition to the two sub-layers in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head attention over the output of the encoder stack. The decoder functions in a similar fashion to the encoder, but an additional attention mechanism is inserted which instead draws relevant information from the encodings generated by the encoders. This mechanism can also be called the encoder-decoder attention.

### Attention
#### Scaled Dot-Product Attention
The input consists of queries and keys of dimension dk, and values of dimension dv. We compute the dot products of the query with all keys, divide each by √d<sub>k</sub>, and apply a softmax function to obtain the weights on the values.

> Attention(Q, K, V) = softmax(QK<sup>T</sup> / √d<sub>k</sub>) * V

#### Multi-Head Attention
Instead of performing a single attention function with d<sub>model</sub>-dimensional keys, values and queries, it is beneficial to linearly project the queries, keys and values h times with different, learned linear projections to d<sub>k</sub>, d<sub>k</sub> and d<sub>v</sub> dimensions, respectively. 

Multi-head attention allows the model to jointly attend to information from different representation
subspaces at different positions. With a single attention head, averaging inhibits this.

> MultiHead(Q, K, V) = Concat(head<sub>1</sub>, <sub>...</sub>, head<sub>h</sub>) * W<sup>O</sup>

where,

> head<sub>i</sub> = Attention(Q * W<sub>i</sub><sup>Q</sup>, K * W<sub>i</sub><sup>K</sup>, V * W<sub>i</sub><sup>V</sup>)

where the projections are parameter matrices.

#### Masked Attention
It may be necessary to cut out attention links between some word-pairs. For example, the decoder for token position 
𝑡 should not have access to token position 𝑡+1.

> MaskedAttention(Q, K, V) = softmax(M + (QK<sup>T</sup> / √d<sub>k</sub>)) * V

### Feed-Forward Network
Each of the layers in the encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and identically. This
consists of two linear transformations with a ReLU activation in between.
> FFN(x) = (max(0, (x * W1) + b1) * W2) + b2

### Positional Encoding
A positional encoding is a fixed-size vector representation that encapsulates the relative positions of tokens within a target sequence: it provides the transformer model with information about where the words are in the input sequence.

The sine and cosine functions of different frequencies:
> PE<sub>(pos,2i)</sub> = sin(pos/10000<sup>2i/dmodel</sup>)

> PE<sub>(pos,2i+1)</sub> = cos(pos/10000<sup>2i/dmodel</sup>)

## Implementation
### Theory
Text is converted to numerical representations called tokens, and each token is converted into a vector via looking up from a word embedding table. 
At each layer, each token is then contextualized within the scope of the context window with other tokens via a parallel multi-head attention mechanism 
allowing the signal for key tokens to be amplified and less important tokens to be diminished. 

The transformer uses an encoder-decoder architecture. The encoder extracts features from an input sentence, and the decoder uses the features to produce an output sentence. Some architectures use full encoders and decoders, autoregressive encoders and decoders, or combination of both. This depends on the usage and context of the input.

### Tensorflow
Tensorflow provides the transformer encoder and decoder block that can be implemented by the specification of the user. Although, the transformer is not provided as a standalone to be imported and executed, the user has to create the model first. They also have a tutorial on how to implement the transformer from scratch for machine translation and can be found [here](https://www.tensorflow.org/text/tutorials/transformer).

More information on [encoder](https://www.tensorflow.org/api_docs/python/tfm/nlp/layers/TransformerEncoderBlock) and [decoder](https://www.tensorflow.org/api_docs/python/tfm/nlp/layers/TransformerDecoderBlock) block mentioned in the code.

Imports:
```python
import tensorflow as tf
import tensorflow_models as tfm
```

Adding word embeddings and positional encoding:
```python
class PositionalEmbedding(tf.keras.layers.Layer):
    def __init__(self, vocab_size, d_model):
        super().__init__()
        self.d_model = d_model
        self.embedding = tf.keras.layers.Embedding(vocab_size, d_model, mask_zero=True) 
        self.pos_encoding = tfm.nlp.layers.RelativePositionEmbedding(hidden_size=d_model)
  
    def compute_mask(self, *args, **kwargs):
        return self.embedding.compute_mask(*args, **kwargs)
  
    def call(self, x):
        length = tf.shape(x)[1]
        x = self.embedding(x)
        x = x + self.pos_encoding[tf.newaxis, :length, :]
        return x
```

Creating the encoder for the transformer:
```python
class Encoder(tf.keras.layers.Layer):
    def __init__(self, num_layers, d_model, num_heads,
                 dff, vocab_size, dropout_rate=0.1):
        super().__init__()
    
        self.d_model = d_model
        self.num_layers = num_layers
    
        self.pos_embedding = PositionalEmbedding(
            vocab_size=vocab_size, d_model=d_model)
    
        self.enc_layers = [
            tfm.nlp.layers.TransformerEncoderBlock(output_last_dim=d_model,
                         num_attention_heads=num_heads,
                         inner_dim=dff,
                         inner_activation="relu",
                         inner_dropout=dropout_rate)
            for _ in range(num_layers)]
        self.dropout = tf.keras.layers.Dropout(dropout_rate)

    def call(self, x):
        x = self.pos_embedding(x, length=2048)
        x = self.dropout(x)
    
        for i in range(self.num_layers):
          x = self.enc_layers[i](x)
    
        return x
```

Creating the decoder for the transformer:
```python
class Decoder(tf.keras.layers.Layer):
    def __init__(self, num_layers, d_model, num_heads, dff, vocab_size,
                 dropout_rate=0.1):
        super(Decoder, self).__init__()
    
        self.d_model = d_model
        self.num_layers = num_layers
    
        self.pos_embedding = PositionalEmbedding(vocab_size=vocab_size,
                                                 d_model=d_model)
        self.dropout = tf.keras.layers.Dropout(dropout_rate)
        self.dec_layers = [
            tfm.nlp.layers.TransformerDecoderBlock(num_attention_heads=num_heads,
                         intermediate_size=dff,
                         intermediate_activation="relu",
                         dropout_rate=dropout_rate)
            for _ in range(num_layers)]
  
    def call(self, x, context):
        x = self.pos_embedding(x)
        x = self.dropout(x)
    
        for i in range(self.num_layers):
            x  = self.dec_layers[i](x, context)
  
        return x
```

Combining the encoder and decoder to create the transformer:
```python
class Transformer(tf.keras.Model):
    def __init__(self, num_layers, d_model, num_heads, dff,
                 input_vocab_size, target_vocab_size, dropout_rate=0.1):
        super().__init__()
        self.encoder = Encoder(num_layers=num_layers, d_model=d_model,
                               num_heads=num_heads, dff=dff,
                               vocab_size=input_vocab_size,
                               dropout_rate=dropout_rate)
      
        self.decoder = Decoder(num_layers=num_layers, d_model=d_model,
                               num_heads=num_heads, dff=dff,
                               vocab_size=target_vocab_size,
                               dropout_rate=dropout_rate)
      
        self.final_layer = tf.keras.layers.Dense(target_vocab_size)

    def call(self, inputs):
        context, x  = inputs
    
        context = self.encoder(context)
        x = self.decoder(x, context)
        logits = self.final_layer(x)
    
        return logits
```

Model initialization that be used for training and inference:
```python
transformer = Transformer(
      num_layers=num_layers,
      d_model=d_model,
      num_heads=num_heads,
      dff=dff,
      input_vocab_size=tokenizers.pt.get_vocab_size().numpy(),
      target_vocab_size=tokenizers.en.get_vocab_size().numpy(),
      dropout_rate=dropout_rate
)
```

### PyTorch
Unlike Tensorflow, PyTorch provides the full implementation of the transformer model that can be executed on the go. More information can be found [here](https://pytorch.org/docs/stable/_modules/torch/nn/modules/transformer.html#Transformer). A full implementation of the model can be found [here](https://github.com/pytorch/examples/tree/master/word_language_model).

Imports:
```python
import torch
import torch.nn as nn
```

Initializing the model:
```python
transformer = nn.Transformer(nhead=16, num_encoder_layers=8)
```

Sample Implementation:
```python
src = torch.rand((10, 32, 512))
tgt = torch.rand((20, 32, 512))

output = transformer(src, tgt)
```

### HuggingFace


## Application
The transformer has had great success in natural language processing (NLP). Many large language models such as GPT-2, GPT-3, GPT-4, Claude, BERT, XLNet, RoBERTa and ChatGPT demonstrate the ability of transformers to perform a wide variety of such NLP-related tasks, and have the potential to find real-world applications.

These may include:
- Machine translation
- Document summarization
- Text generation
- Biological sequence analysis
- Computer code generation
- Video analysis
